-- EXECÃ˜ Loader Guard
local EXEC0_KEY = "escape tsunami/main.txt"
local function EXEC0_isOn()
    local t = getgenv().EXEC0_TOGGLES
    return t and t[EXEC0_KEY]
end

if getgenv().EXEC0_LOADER and not EXEC0_isOn() then
    return
end

local function EXEC0_wait(...)
    if getgenv().EXEC0_LOADER and not EXEC0_isOn() then
        error("EXEC0_STOP")
    end
    return wait(...)
end

local function EXEC0_task_wait(...)
    if getgenv().EXEC0_LOADER and not EXEC0_isOn() then
        error("EXEC0_STOP")
    end
    return task.wait(...)
end

local function EXEC0_run()
    getgenv().InterfaceName = "EXECÃ˜"
    -- Prevent Starlight acrylic/blur init from crashing on some games
    getgenv().SecureMode = true
    
    local Starlight = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/starlight"))()
    local NebulaIcons = loadstring(game:HttpGet("https://raw.nebulasoftworks.xyz/nebula-icon-library-loader"))()
    
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")
    local TeleportService = game:GetService("TeleportService")
    local HttpService = game:GetService("HttpService")
    local UserInputService = game:GetService("UserInputService")
    local MarketplaceService = game:GetService("MarketplaceService")
    
    local LocalPlayer = Players.LocalPlayer
    local Remotes = ReplicatedStorage:FindFirstChild("RemoteFunctions")
    
    local state = {
        autoSell = false,
        autoUpgradeSpeed = false,
        autoUpgradeCarry = false,
        autoRebirth = false,
        autoCollectCash = false,
        autoGoldBar = false,
        instantProximity = false,
        freeVipWalls = false,
        biggerHitbox = false,
        godmode = false,
        walkSpeed = 16,
    }
    
    local connections = {
        hitbox = nil,
        proximity = nil,
        charAdded = nil,
        cashCollector = nil,
        goldBarCollector = nil,
        godmodeHeartbeat = nil,
        godmodeHealthChanged = nil,
    }
    
    local uiElements = {
        autoCollectToggle = nil,
    }
    
    
    local function applyWalkSpeed()
        local v = LocalPlayer:GetAttribute("CurrentSpeed")
        if type(v) ~= "number" then
            v = state.walkSpeed
        else
            state.walkSpeed = v
        end
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = v
        end
    end
    
    applyWalkSpeed()
    
    local function getBase()
        local bases = workspace:FindFirstChild("Bases")
        if not bases then return nil end
        for _, model in pairs(bases:GetChildren()) do
            if model:IsA("Model") and model:GetAttribute("Holder") == LocalPlayer.UserId then
                return model
            end
        end
        return nil
    end
    
    local function teleportHome()
        local base = getBase()
        if base and base:FindFirstChild("Home") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = base.Home.CFrame
        end
    end
    
    local function optimizePrompts()
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("ProximityPrompt") then
                v.HoldDuration = 0
                v.MaxActivationDistance = 20
            end
        end
    end
    
    -- NEW: TouchInterest-based Auto Collect Cash
    local function autoCollectCash()
        if not state.autoCollectCash then return end
        
        local myBase = getBase()
        if not myBase then 
            warn("No base found for player")
            return 
        end
        
        local slotsFolder = myBase:FindFirstChild("Slots")
        if not slotsFolder then
            warn("No Slots folder found in base")
            return
        end
        
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        -- Loop through all numbered slots
        for _, slot in pairs(slotsFolder:GetChildren()) do
            if not state.autoCollectCash then break end
            
            if slot.Name:match("%d+") then  -- Numbered slots only
                local collect = slot:FindFirstChild("Collect")
                if collect and collect:FindFirstChild("TouchInterest") then
                    pcall(function()
                        firetouchinterest(collect, hrp, 0)  -- Touch
                        task.wait(0.05)
                        firetouchinterest(collect, hrp, 1)  -- Untouch
                    end)
                end
            end
        end
    end
    
    local function setAutoCollectCash(enabled)
        if connections.cashCollector then
            task.cancel(connections.cashCollector)
            connections.cashCollector = nil
        end
        
        if not enabled then return end
        
        -- Create a loop that runs the collection using TouchInterest
        connections.cashCollector = task.spawn(function()
            while state.autoCollectCash do
                pcall(autoCollectCash)
                task.wait(0.4) -- Wait between collection cycles
            end
        end)
    end
    
    -- Escape Tsunami teleport path (ordered CFrames)
    local tpPath = {
        CFrame.new(209.12, -1.68, 9.31),
        CFrame.new(284.90, -1.68, -10.87),
        CFrame.new(396.80, -1.68, -9.93),
        CFrame.new(545.08, -1.68, -8.69),
        CFrame.new(755.92, -1.68, -10.17),
        CFrame.new(1079.21, -1.68, -4.46),
        CFrame.new(1550.63, -1.68, -5.79),
        CFrame.new(2255.23, -1.68, 10.90),
        CFrame.new(2608.95, -1.68, 6.86),
    }
    local lobbyCFrame = CFrame.new(157.004, 0, 28.863)
    
    local tpSpeed = 120
    local noclipConn = nil
    local noclipState = nil
    local teleportAbort = false
    
    local function setNoclip(enabled)
        if noclipConn then
            noclipConn:Disconnect()
            noclipConn = nil
        end
        if not enabled then
            local char = LocalPlayer.Character
            if char and noclipState then
                for part, canCollide in pairs(noclipState) do
                    if part and part.Parent then
                        part.CanCollide = canCollide
                    end
                end
            end
            noclipState = nil
            return
        end
        noclipState = {}
        noclipConn = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if not char then return end
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    if noclipState[part] == nil then
                        noclipState[part] = part.CanCollide
                    end
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function isTsunamiNear(pos, radius)
        local folder = workspace:FindFirstChild("ActiveTsunamis")
        if not folder then return false end
        local r2 = radius * radius
        for _, inst in ipairs(folder:GetDescendants()) do
            if inst:IsA("BasePart") then
                if (inst.Position - pos).Magnitude^2 <= r2 then
                    return true
                end
            end
        end
        return false
    end
    
    local function waitForClearTsunami(root, radius)
        local tries = 0
        while root and isTsunamiNear(root.Position, radius) do
            task.wait(0.15)
            tries += 1
            if tries >= 40 then
                break
            end
        end
    end
    
    local GAP_SPEED = 800
    local GAP_OFFSET = Vector3.new(0, 3, 0)
    local gapPoints = {
        Vector3.new(199.373, -2.821, 3.563),
        Vector3.new(284.762, -2.821, 7.194),
        Vector3.new(398.675, -2.821, 5.099),
        Vector3.new(542.724, -2.821, -0.361),
        Vector3.new(757.582, -2.821, -5.480),
        Vector3.new(1073.923, -2.821, -1.892),
        Vector3.new(1550.606, -2.821, -15.562),
        Vector3.new(2246.533, -2.821, -4.761),
        Vector3.new(2602.190, -2.821, -5.724),
    }
    local gapIndex = 1
    
    local function moveToGapPoint(pos)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local duration = (hrp.Position - pos).Magnitude / GAP_SPEED
        TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
            CFrame = CFrame.new(pos + GAP_OFFSET),
        }):Play()
    end
    
    local function autoCollectGoldBars()
        if not state.autoGoldBar then return end
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
    
        local moneyParts = workspace:FindFirstChild("MoneyEventParts")
        local goldFolder = moneyParts and moneyParts:FindFirstChild("GoldBar")
        if not goldFolder then return end
    
        for _, bar in ipairs(goldFolder:GetChildren()) do
            if not state.autoGoldBar then break end
            local main = bar:IsA("BasePart") and bar or bar:FindFirstChild("Main", true)
            if main and main:IsA("BasePart") and main:FindFirstChild("TouchInterest") then
                pcall(function()
                    local start = os.clock()
                    while state.autoGoldBar and main and main.Parent and (os.clock() - start) < 0.6 do
                        firetouchinterest(main, hrp, 0)
                        task.wait(0.03)
                        firetouchinterest(main, hrp, 1)
                        task.wait(0.03)
                    end
                end)
            end
        end
    end
    
    local function setAutoCollectGoldBars(enabled)
        if connections.goldBarCollector then
            task.cancel(connections.goldBarCollector)
            connections.goldBarCollector = nil
        end
        if not enabled then return end
    
        connections.goldBarCollector = task.spawn(function()
            while state.autoGoldBar do
                pcall(autoCollectGoldBars)
                task.wait(0.2)
            end
        end)
    end
    
    local travelPath
    
    local function teleportPathSpeed(speedStudsPerSec)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        if not root then return end
        local speed = math.max(1, speedStudsPerSec or tpSpeed)
    
        teleportAbort = false
        local diedConn = nil
        if humanoid then
            diedConn = humanoid.Died:Connect(function()
                teleportAbort = true
                setNoclip(false)
            end)
        end
    
        setNoclip(true)
        local ok, err = pcall(function()
            travelPath(tpPath, speed, #tpPath)
        end)
        setNoclip(false)
        if diedConn then diedConn:Disconnect() end
        if not ok then error(err) end
    end
    
    local function getClosestIndex(path, pos)
        local bestIndex = 1
        local bestDist = math.huge
        for i, cf in ipairs(path) do
            local dist = (pos - cf.Position).Magnitude
            if dist < bestDist then
                bestDist = dist
                bestIndex = i
            end
        end
        return bestIndex
    end
    
    local function getTargetCFrame(target)
        if typeof(target) == "CFrame" then
            return target
        end
        if typeof(target) == "Instance" then
            if target:IsA("BasePart") then
                return target.CFrame
            elseif target:IsA("Model") then
                return target:GetPivot()
            end
        end
        return nil
    end
    
    local function reversePath(path)
        local rev = {}
        for i = #path, 1, -1 do
            rev[#rev + 1] = path[i]
        end
        return rev
    end
    
    local function pathToTarget(targetCf)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local startIndex = root and getClosestIndex(tpPath, root.Position) or 1
        local path = {}
        for i = startIndex, #tpPath do
            path[#path + 1] = tpPath[i]
        end
        path[#path + 1] = targetCf
        return path
    end
    
    local function pathBackToLobby()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local startIndex = root and getClosestIndex(tpPath, root.Position) or 1
        local path = {}
        for i = startIndex, 1, -1 do
            path[#path + 1] = tpPath[i]
        end
        path[#path + 1] = lobbyCFrame
        return path
    end
    
    local function isAtLobby()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if not root then return false end
        return (root.Position - lobbyCFrame.Position).Magnitude <= 8
    end
    
    travelPath = function(pathList, speed, baseCount)
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChild("Humanoid")
        if not root then return false end
    
        local lastSafeIndex = getClosestIndex(tpPath, root.Position)
        local lastSafe = tpPath[lastSafeIndex] or root.CFrame
        local retreatTarget = nil
        local retreating = false
        local clearStart = nil
        local clearSeconds = 0.8
    
        local function isThreatNear(currentPos, targetPos)
            if isTsunamiNear(currentPos, 60) or isTsunamiNear(targetPos, 60) then
                return true
            end
            local delta = Vector3.new(targetPos.X - currentPos.X, 0, targetPos.Z - currentPos.Z)
            if delta.Magnitude > 0 then
                local lookahead = currentPos + (delta.Unit * math.min(60, delta.Magnitude))
                if isTsunamiNear(lookahead, 60) then
                    return true
                end
            end
            return false
        end
    
        local function moveToTarget(forwardTarget)
            while root and not teleportAbort do
                if humanoid and humanoid.Health <= 0 then return false end
    
                local threat = isThreatNear(root.Position, forwardTarget.Position)
                if threat then
                    retreatTarget = tpPath[lastSafeIndex] or lastSafe
                    retreating = true
                    clearStart = nil
                elseif retreating and retreatTarget then
                    local retreatDist = (root.Position - retreatTarget.Position).Magnitude
                    if not clearStart then
                        if retreatDist <= 0.5 then
                            clearStart = os.clock()
                        end
                    elseif retreatDist <= 0.5 and os.clock() - clearStart >= clearSeconds then
                        retreating = false
                        retreatTarget = nil
                        clearStart = nil
                    elseif retreatDist > 0.5 then
                        clearStart = nil
                    end
                end
    
                if not root then return false end
    
                local target = retreating and retreatTarget or forwardTarget
                local current = root.Position
                local targetPos = target.Position
                local delta = Vector3.new(targetPos.X - current.X, 0, targetPos.Z - current.Z)
                local dist = delta.Magnitude
    
                if dist <= 0.5 then
                    root.CFrame = target
                    root.AssemblyLinearVelocity = Vector3.new()
                    if retreating and target == retreatTarget then
                        RunService.Heartbeat:Wait()
                        continue
                    end
                    return true
                end
    
                local dt = RunService.Heartbeat:Wait()
                local step = math.min(dist, speed * dt)
                local nextPos = current + (delta.Unit * step)
                root.CFrame = CFrame.new(nextPos.X, targetPos.Y, nextPos.Z)
                root.AssemblyLinearVelocity = Vector3.new()
            end
            return false
        end
    
        for i, target in ipairs(pathList) do
            if teleportAbort then return false end
            local reached = moveToTarget(target)
            if not reached then return false end
            if baseCount and i <= baseCount then
                lastSafeIndex = i
                lastSafe = tpPath[lastSafeIndex] or lastSafe
            else
                lastSafeIndex = getClosestIndex(tpPath, root.Position)
                lastSafe = tpPath[lastSafeIndex] or lastSafe
            end
        end
    
        return true
    end
    
    -- Rejoin current server
    local function rejoinServer()
        local placeId = game.PlaceId
        local jobId = game.JobId
        
        if jobId and jobId ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobId, LocalPlayer)
        else
            TeleportService:Teleport(placeId, LocalPlayer)
        end
    end
    
    -- Find and join a new server
    local function joinNewServer()
        local placeId = game.PlaceId
        local currentJobId = game.JobId
        
        local success, result = pcall(function()
            local serversUrl = string.format(
                "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100",
                placeId
            )
            
            local serversData = HttpService:JSONDecode(game:HttpGet(serversUrl))
            
            if serversData and serversData.data then
                -- Filter out current server and find a suitable one
                for _, server in ipairs(serversData.data) do
                    if server.id ~= currentJobId and server.playing < server.maxPlayers then
                        TeleportService:TeleportToPlaceInstance(placeId, server.id, LocalPlayer)
                        return
                    end
                end
                
                -- If no different server found, just teleport to a random one
                warn("No different server found, rejoining any server...")
                TeleportService:Teleport(placeId, LocalPlayer)
            end
        end)
        
        if not success then
            warn("Failed to find new server:", result)
            -- Fallback to regular teleport
            TeleportService:Teleport(placeId, LocalPlayer)
        end
    end
    
    local function disableVipWalls()
        local walls = workspace:FindFirstChild("VIPWalls")
        if not walls then return end
        for _, v in pairs(walls:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            elseif v:IsA("TouchTransmitter") then
                v:Destroy()
            end
        end
    end
    
    local function disableHumanoidDied(humanoid)
        if not humanoid or not getconnections then return end
        local ok, conns = pcall(getconnections, humanoid.Died)
        if not ok or not conns then return end
        for _, conn in ipairs(conns) do
            pcall(function() conn:Disable() end)
        end
    end
    
    local function updateHitboxes()
        local char = LocalPlayer.Character
        if not char then return end
    
        local tracked = {}
        local function scanTool(tool)
            if tool:IsA("Tool") then
                local hitbox = tool:FindFirstChild("Hitbox")
                if hitbox and hitbox:IsA("BasePart") then
                    table.insert(tracked, hitbox)
                end
            end
        end
    
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            scanTool(tool)
        end
        for _, tool in ipairs(char:GetChildren()) do
            scanTool(tool)
        end
        if #tracked == 0 then return end
    
        local myRoot = char:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
    
        local nearby = {}
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (plr.Character.HumanoidRootPart.Position - myRoot.Position).Magnitude
                if dist < 50 then
                    table.insert(nearby, plr.Character.HumanoidRootPart)
                end
            end
        end
    
        if #nearby > 0 then
            local totalPos = Vector3.new()
            for _, part in ipairs(nearby) do
                totalPos += part.Position
            end
            local targetPos = totalPos / #nearby
            if #nearby == 1 then
                local direction = (nearby[1].Position - myRoot.Position).Unit
                targetPos = nearby[1].Position + direction * 2
            end
    
            local finalSize
            if #nearby == 1 then
                finalSize = Vector3.new(20, 20, 18)
            else
                finalSize = Vector3.new(150, 150, 150)
            end
    
            for _, hb in ipairs(tracked) do
                hb.Size = finalSize
                hb.Position = targetPos
                hb.Transparency = 0.7
                hb.CanCollide = false
            end
        else
            for _, hb in ipairs(tracked) do
                hb.Size = Vector3.new(4, 4, 4)
            end
        end
    end
    
    local function setHitboxEnabled(enabled)
        if connections.hitbox then
            connections.hitbox:Disconnect()
            connections.hitbox = nil
        end
        if not enabled then return end
    
        connections.hitbox = RunService.Heartbeat:Connect(function()
            local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                updateHitboxes()
            end
        end)
    end
    
    local function setInstantProximity(enabled)
        if connections.proximity then
            connections.proximity:Disconnect()
            connections.proximity = nil
        end
        if not enabled then return end
    
        optimizePrompts()
        connections.proximity = workspace.DescendantAdded:Connect(function(inst)
            if inst:IsA("ProximityPrompt") then
                inst.HoldDuration = 0
                inst.MaxActivationDistance = 20
            end
        end)
    end
    
    -- AGGRESSIVE GODMODE IMPLEMENTATION - Survive 1-2 Hits
    local GODMODE_HP = 100000000  -- 100 million HP
    
    local function setGodmodeEnabled(enabled)
        -- Always disconnect existing connections first
        if connections.godmodeHeartbeat then
            connections.godmodeHeartbeat:Disconnect()
            connections.godmodeHeartbeat = nil
        end
        if connections.godmodeHealthChanged then
            connections.godmodeHealthChanged:Disconnect()
            connections.godmodeHealthChanged = nil
        end
        
        if not enabled then 
            -- Reset to normal when disabled
            local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.MaxHealth = 100
                humanoid.Health = 100
            end
            return 
        end
        
        -- Wait for character to be fully loaded
        local char = LocalPlayer.Character
        if not char then
            warn("Character not found, waiting...")
            return
        end
        
        local humanoid = char:FindFirstChild("Humanoid")
        if not humanoid then
            warn("Humanoid not found, waiting...")
            return
        end
        
        -- Disable died event
        disableHumanoidDied(humanoid)
        
        -- Set extremely high HP
        humanoid.MaxHealth = GODMODE_HP
        humanoid.Health = GODMODE_HP
        
        -- Method 1: HealthChanged - instant heal when damaged
        connections.godmodeHealthChanged = humanoid.HealthChanged:Connect(function(health)
            if health < GODMODE_HP * 0.95 then  -- If health drops below 95%
                humanoid.Health = GODMODE_HP
            end
        end)
        
        -- Method 2: Prevent damage via GetPropertyChangedSignal
        pcall(function()
            humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                if humanoid.Health < GODMODE_HP then
                    humanoid.Health = GODMODE_HP
                end
            end)
        end)
        
        -- Method 3: Aggressive Heartbeat loop - heal every single frame
        connections.godmodeHeartbeat = RunService.Heartbeat:Connect(function()
            local currentChar = LocalPlayer.Character
            if not currentChar then return end
            
            local hum = currentChar:FindFirstChild("Humanoid")
            if hum then
                -- Re-disable died event if it gets re-enabled somehow
                if state.godmode then
                    pcall(function()
                        disableHumanoidDied(hum)
                    end)
                end
                
                -- Constantly enforce max health every frame
                if hum.MaxHealth ~= GODMODE_HP then
                    hum.MaxHealth = GODMODE_HP
                end
                
                -- Heal every single frame if health is not at max
                if hum.Health < GODMODE_HP then
                    hum.Health = GODMODE_HP
                end
            end
        end)
        
        print("âœ… Godmode enabled with 100M HP!")
    end
    
    connections.charAdded = LocalPlayer.CharacterAdded:Connect(function(char)
        -- Wait for humanoid to load
        local humanoid = char:WaitForChild("Humanoid", 10)
        if not humanoid then
            warn("Humanoid failed to load after respawn")
            return
        end
        
        -- Wait a bit for character to fully load
        task.wait(0.5)
        
        -- Re-apply walk speed
        applyWalkSpeed()
        
        -- Re-enable godmode if it was toggled on
        if state.godmode then
            print("ðŸ”„ Re-enabling godmode after respawn...")
            setGodmodeEnabled(true)
        end
        
        -- Re-enable bigger hitbox if it was toggled on
        if state.biggerHitbox then
            task.wait(0.2)
            updateHitboxes()
        end
    end)
    
    -- Get current game name
    local gameName = "Universal"
    pcall(function()
        local productInfo = MarketplaceService:GetProductInfo(game.PlaceId)
        gameName = productInfo.Name
    end)
    
    local Window = Starlight:CreateWindow({
        Name = "EXECÃ˜",
        Subtitle = gameName,
        Icon = 112874313118407,
        
        LoadingEnabled = true,
        LoadingSettings = {
            Title = "EXECÃ˜ Hub",
            Subtitle = "Welcome to EXECÃ˜",
            Logo = 112874313118407,
        },
    
        FileSettings = {
            ConfigFolder = "EXECÃ˜",
        },
    })
    
    local TabSection = Window:CreateTabSection("Main")
    local MainTab = TabSection:CreateTab({
        Name = "Automation",
        Icon = NebulaIcons:GetIcon("autorenew", "Material"),
        Columns = 2,
    }, "automation")
    
    local UtilityTab = TabSection:CreateTab({
        Name = "Utility",
        Icon = NebulaIcons:GetIcon("build", "Material"),
        Columns = 2,
    }, "utility")
    
    local AutoBox = MainTab:CreateGroupbox({
        Name = "Automation",
        Column = 1,
    }, "auto_box")
    
    local UpgradesBox = MainTab:CreateGroupbox({
        Name = "Upgrades",
        Column = 2,
    }, "upgrades_box")
    
    AutoBox:CreateToggle({
        Name = "Auto Sell All",
        CurrentValue = false,
        Callback = function(v) state.autoSell = v end,
    }, "auto_sell")
    
    AutoBox:CreateToggle({
        Name = "Auto Rebirth",
        CurrentValue = false,
        Callback = function(v) state.autoRebirth = v end,
    }, "auto_rebirth")
    
    AutoBox:CreateToggle({
        Name = "Auto Collect Gold Bars",
        CurrentValue = false,
        Callback = function(v)
            state.autoGoldBar = v
            setAutoCollectGoldBars(v)
        end,
    }, "auto_goldbar")
    
    -- Auto Collect Cash Toggle (now using TouchInterest)
    uiElements.autoCollectToggle = AutoBox:CreateToggle({
        Name = "Auto Collect Cash",
        CurrentValue = false,
        Callback = function(v) 
            state.autoCollectCash = v 
            setAutoCollectCash(v)
        end,
    }, "auto_collect_cash")
    
    UpgradesBox:CreateToggle({
        Name = "Auto Upgrade Speed",
        CurrentValue = false,
        Callback = function(v) state.autoUpgradeSpeed = v end,
    }, "auto_speed")
    
    UpgradesBox:CreateToggle({
        Name = "Auto Upgrade Carry",
        CurrentValue = false,
        Callback = function(v) state.autoUpgradeCarry = v end,
    }, "auto_carry")
    
    local WorldBox = UtilityTab:CreateGroupbox({
        Name = "World",
        Column = 1,
    }, "world_box")
    
    local PlayerBox = UtilityTab:CreateGroupbox({
        Name = "Player",
        Column = 2,
    }, "player_box")
    
    local ServerBox = UtilityTab:CreateGroupbox({
        Name = "Server",
        Column = 2,
    }, "server_box")
    
    WorldBox:CreateToggle({
        Name = "Instant Proximity",
        CurrentValue = false,
        Callback = function(v)
            state.instantProximity = v
            setInstantProximity(v)
        end,
    }, "instant_prompt")
    
    WorldBox:CreateToggle({
        Name = "Free VIP Walls",
        CurrentValue = false,
        Callback = function(v)
            state.freeVipWalls = v
            if v then
                LocalPlayer:SetAttribute("HasVip", true)
                disableVipWalls()
            end
        end,
    }, "free_vip")
    
    WorldBox:CreateButton({
        Name = "Teleport Home",
        Callback = function()
            teleportHome()
        end,
    }, "teleport_home")
    
    WorldBox:CreateSlider({
        Name = "Teleport Speed",
        Range = {10, 300},
        Increment = 5,
        CurrentValue = tpSpeed,
        Suffix = " studs/s",
        Callback = function(v)
            tpSpeed = v
        end,
    }, "teleport_speed")
    
    WorldBox:CreateButton({
        Name = "Teleport Secret (Speed)",
        Callback = function()
            teleportPathSpeed(tpSpeed)
        end,
    }, "teleport_secret_speed")
    
    WorldBox:CreateButton({
        Name = "Gap Up",
        Callback = function()
            if gapIndex <= #gapPoints then
                moveToGapPoint(gapPoints[gapIndex])
                gapIndex = math.min(gapIndex + 1, #gapPoints)
            end
        end,
    }, "gap_up")
    
    WorldBox:CreateButton({
        Name = "Gap Down",
        Callback = function()
            if gapIndex > 1 then
                gapIndex = math.max(gapIndex - 1, 1)
                moveToGapPoint(gapPoints[gapIndex])
            end
        end,
    }, "gap_down")
    
    -- Server Actions Buttons
    ServerBox:CreateButton({
        Name = "Rejoin Server",
        Callback = function()
            rejoinServer()
        end,
    }, "rejoin_server")
    
    ServerBox:CreateButton({
        Name = "Join New Server",
        Callback = function()
            joinNewServer()
        end,
    }, "new_server")
    
    PlayerBox:CreateToggle({
        Name = "Bigger Hitbox",
        CurrentValue = false,
        Callback = function(v)
            state.biggerHitbox = v
            setHitboxEnabled(v)
        end,
    }, "bigger_hitbox")
    
    PlayerBox:CreateSlider({
        Name = "Walk Speed",
        Range = {16, 1000},
        Increment = 5,
        CurrentValue = state.walkSpeed,
        Callback = function(v)
            LocalPlayer:SetAttribute("CurrentSpeed", v)
            applyWalkSpeed()
        end,
    }, "walk_speed")
    
    PlayerBox:CreateToggle({
        Name = "Godmode ( Survive 1-2 hits )",
        CurrentValue = false,
        Callback = function(v)
            state.godmode = v
            setGodmodeEnabled(v)
        end,
    }, "godmode")
    
    
    task.spawn(function()
        while task.wait(0.1) do
            if state.autoSell and Remotes and Remotes:FindFirstChild("SellAll") then
                pcall(function() Remotes.SellAll:InvokeServer() end)
            end
            if state.autoUpgradeSpeed and Remotes and Remotes:FindFirstChild("UpgradeSpeed") then
                pcall(function() Remotes.UpgradeSpeed:InvokeServer(5) end)
            end
            if state.autoUpgradeCarry and Remotes and Remotes:FindFirstChild("UpgradeCarry") then
                pcall(function() Remotes.UpgradeCarry:InvokeServer() end)
            end
            if state.autoRebirth and Remotes and Remotes:FindFirstChild("Rebirth") then
                pcall(function() Remotes.Rebirth:InvokeServer() end)
            end
            if state.freeVipWalls then
                pcall(disableVipWalls)
            end
        end
    end)
    
    print("âœ… EXECÃ˜ Hub loaded with GODMODE (Survive 1-2 Wave Hits)!")
end

if getgenv().EXEC0_LOADER then
    local ok, err = pcall(function()
        local wait = EXEC0_wait
        local task = {
            wait = EXEC0_task_wait,
            spawn = task.spawn,
            defer = task.defer,
            delay = task.delay,
        }
        EXEC0_run()
    end)
    if not ok and tostring(err) ~= "EXEC0_STOP" then
        warn(err)
    end
else
    EXEC0_run()
end
